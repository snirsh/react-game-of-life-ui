import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { incrementAsync } from './counter-thunks';

export type CounterState = {
	value: number;
	status: 'idle' | 'loading' | 'failed';
};

const initialCounterState: CounterState = {
	value: 0,
	status: 'idle',
};

export function getCounterSlice(initialState: CounterState) {
	return createSlice({
		name: 'counter',
		initialState,
		reducers: {
			increment: (state) => {
				// Redux Toolkit allows us to write "mutating" logic in reducers. It
				// doesn't actually mutate the state because it uses the Immer library,
				// which detects changes to a "draft state" and produces a brand new
				// immutable state based off those changes
				state.value += 1;
			},
			decrement: (state) => {
				state.value -= 1;
			},
			// Use the PayloadAction type to declare the contents of `action.payload`
			incrementByAmount: (state, action: PayloadAction<number>) => {
				state.value += action.payload;
			},
		},
		// The `extraReducers` field lets the slice handle actions defined elsewhere,
		// including actions generated by createAsyncThunk or in other slices.
		extraReducers: (builder) => {
			builder
				.addCase(incrementAsync.pending, (state) => {
					state.status = 'loading';
				})
				.addCase(incrementAsync.fulfilled, (state, action) => {
					state.status = 'idle';
					state.value += action.payload;
				})
				.addCase(incrementAsync.rejected, (state) => {
					state.status = 'failed';
				});
		},
	});
}

const counterSlice = getCounterSlice(initialCounterState);

export const counterReducer = counterSlice.reducer;
export const { increment, decrement, incrementByAmount } = counterSlice.actions;
